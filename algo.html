<!--commentaire-->
<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8"/>
		<link rel="stylesheet" href="css/fich.css"/>
		<title>Algorithme</title>
		<script src = "monScript.js"></script>
    </head>
    <body>
			<header>
					<nav class="navbar navbar-expand-md navbar-dark fixed-top menu">
						<a class="navbar-brand" href="HTML.html">Acceuil</a>
						<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
							<span class="navbar-toggler-icon"></span>
						</button>
					</nav>
				</header>
		<div class="body">
			<center><h1><p><font>ALGORITHME</center></font></h1><p>
			<div>
				<ol type="I">
					<li class="titre"><font size=4>	<u>Définition</u></i></font><p>
						<font size=4>
						<font color="azure">
							L’algorithme est l’ensemble des étapes qu’il faut franchir pour résoudre un problème spécifique. Pour pouvoir résoudre un
							problème, il faut avant tout comprendre celui-ci. Il faut se poser les questions suivantes :<br>
							<ul>
								<li><u class="crime">Qu’est-ce qu’on attend exactement de moi ?</u>cette question nous oriente vers le résultat attendu <br>
								<li><u class="crime">Qu’est-ce que j’ai besoin ?</u>ici on définie les éléments initiaux, nécessaire à la résolution du problème<br>
							</ul>
							Il ne suffit pas seulement de trouver les étapes, il faut arranger ces étapes dans un ordre logique et les représenter sous une
							forme normalisée plus ou moins facile à comprendre. Il existe plusieurs manières de représenter un algorithme. Pour notre cas, 
							nous allons utiliser l’ordinogramme.
						</font><br><br>
					<li class="titre"><u>Ce qu’on voit dans un algorithme:</u>
							<p><img src="sar1.jpg"><p>

					<li class="titre"><u >Caractéristique d’un algo</u><Br>
						<font color="azure">
						L’algo est un moyen pour le programmeur de présenter son approche du problème à d’autre personne. En effet un algo est l’énoncé d’une
						suite   d’opération permettant de répondre au problème. Ainsi un algo doit être :
						<ul>
							<li><b><u class="ver">lisible:</u></b> même par un non informaticien l’algo doit être compréhensible<br>
							<li><b><u class="ver">de haut niveau </b>:</u> l’algo doit pouvoir être traduit en importe quelle langage de programmation. Il ne
								doit pas faire appel à des notions techniques relatives à un programme particulier ou bien à un SE donné<br>
							<li><b><u class="ver">précis </b>:</u> chaque élément de l’algo ne doit pas porter à confusion, il est très important de lever 
								toute ambigüité<br>
							<li><b><u class="ver">concis </b>: </u>un algo ne doit pas être trop long. Si c’est le cas, il faut décomposer le problème en 
								plusieurs sous problèmes<br>
							<li><b><u class="ver">structuré </b>:</u> un algo doit être composé de différente partie facilement identifiable<br>
						</ul>
						<br><u classe="crime"><b>Remarque:</u></b>
							Un algo est dit séquentiel si ses instructions s’exécutent les une après les autres. Si ses instructions s’exécutent en même temps 
							il est parallèle. Et si l’algo exploite des tâches s’exécutant sur un réseau de processeur on parle d’algo réparti.<p>
						</font><br>
					<li class="titre"><u>Les structures de contrôles: </u><br>
						<ol type=a>
							<li class="ver"><u>structure alternative</u><br>
								<font color="azure">
								C’est une structure qui permet d’exécuter une ou plusieurs instructions selon la valeur d’une condition. Il existe 3 formes:
								<ul> 
									<font color="chartreuse">
										<il>- forme générale<br>
											<img src="sar2.jpg" width=800; height=400><p>
										<il>- forme simplifiée<br>
											<img src="sar3.jpg" width=800; height=400><p>
										<il>- forme imbriquée<br>
									</font>
											<img src="sar4.jpg" width=800; height=400><p>
								</ul>
								</font>
							<li class="ver"><u>structure itérative</u><br>
								<font color="azure">
								Une structure itérative est une structure qui permet d’exécuter une ou plusieurs instructions jusqu’à satisfaction d’une 
								condition. Il existe 2 formes :
								<ul>
									<font color="chartreuse">
										<il>- forme « tant que…faire »<br>
											<img src="sar6.jpg"><p>
										<il>- forme « répéter…jusqu’à… »<br>
									</font>
											<img src="sar5.jpg"><p>
								</ul>
								</font>
						</ol>
				</ol><br>
			</div>
			<b><center><h1><p><font>LA PROGRAMMATION</font></center></b></h1><p>
			<div>
				<b><u>
				<ol type=A>
					<li class="titre">Introduction</u></b><br>	
						<font color="azure">
							Un ordinateur est une machine ne sachant qu’obéir à très peu de chose tel que :
							<ul class="demo">
								<li>addition, soustraction, multiplication en binaire, uniquement sur des entiers
								<li>sortir un résultat ou lire une valeur binaire
								<li>comparer des nombres<br>
							</ul>
						</font>
						<font color="azure">
							La puissance d’un ordinateur vient du fait qu’il peut être programmé c’est-à-dire que l’on peut lui donner à l’avance la séquence
							des ordres à effectuer l’un après l’autre. Le grand avantage de l’ordinateur est sa rapidité. Par contre, c’est le programmeur qui
							doit tout faire. L’ordinateur ne comprenant que des ordres codés en binaire, des langages dit évolués ont été mis au point pour
							faciliter la programmation.</br>
							<br>Le<b> « PASCAL »</b> créé par WIRTH au début des années 70 possède des instructions assez claires et favorise une approche 
							méthodique et structuré. Le Pascal est un langage compilé c’est-à-dire qu’il faut :
							<ul>
								<li>entrer un texte dans l’ordinateur (à l’aide d’un programme appelé éditeur)
								<li>le traduire en langage machine c’est-à-dire un code binaire compréhensible par l’ordinateur : c’est la compilation et 
									éventuellement l’édition de lien (LINK)
								<li>l’exécuter
								<li>Contrairement à un basique interpréter l’exécution sera beaucoup plus rapide puisqu’il n’y aura plus à effectuer.
							</ul><p>
						</font>

						<br><u><b>
					<li class="titre"> Structure d’un programme en Pascal</u></b>
						<font color="black">
							<ul>
								<li>Program nom du programme ;
								<li>Uses nom  bibliothèque ;
								<li>Const identificateur=valeur ;
								<li>Type nom de type=description ;
								<li>Var  identificateur1=type1 ;

										<ul>
											<li>identificateur2=type2 ;
												<ul>
													<il>begin
														<ul>
															<il>instruction1 ;
															<il>instruction2 ;
														</ul>
													<il>end.<br>
												</ul>
										</ul>
							</ul>
						</font>
						<br><u class="crime"><b>REMARQUE</u></b>
						<br>
							<font color="azure">Le langage Pascal ne distingue pas les majuscules et les minuscules, ignore les tabulations, les répétitions
								d’espace et les retours à la ligne. Ces mises en forme de texte sont donc facultatives. Elles ont pour but la lisibilité du code 
								source. Il y a donc intérêt à les utiliser rationnellement
								<ul>
									<li>Les instructions sont terminées par un « ; »
									<li>Les retours à la ligne et les tabulations (indentation) sont facultatifs mais fortement recommandés
									<li>Le « end » final est suivit d’un « . » tout ce qui suivra sera ignorer par le compilateur
									<li>Ce qui est entre{…} est ignorer par le compilateur : cela constitue un <b>commentaire</b>
								</ul>
								<br>Un programme Pascal est composé d’une tête, d’une partie déclarative et d’un corps : 
								<ul>
									<li><b><u class="belge">L’entête:</u></b> est composé du mot programme suivi du nom du programme
									<li><b><u class="belge">La partie déclarative:</u></b> de notre programme est limitée à la déclarative de 2 variables ainsi
										que de l’insertion d’une bibliothèque appelé : <font color="crimson">crt.</font>
								</ul><p>
							</font>
						<br>
					<li class="titre"><u><b>quelques définitions:</b></u><p>
						<ul>
							<font color="azure">
								<li><b><u class="ver">variable : </b></u>c’est un emplacement en mémoire vive réserver par le programmeur. Cet emplacement doit 
									avoir un nom, respectant les règles standards d’affectation de nom et un type qui définit la taille de l’emplacement réservé.<br>

								<li><b><u class="ver">Programmation :</b></u> c’est la traduction d’un algorithme en un langage compris par l’ordinateur.<br>
							</font>
						</ul><br>
					<li class="titre"><u><b>Principaux élément du code</u></b><br>
						<ul>
							<li class="belge"><u>Déclaration d’une variable</u>
								<font color="azure">
									<i><u class="crime">syntaxe :</u></i> var NomVar : type ; 
									<ul>
										<li>Déclarer une variable c’est réservée une certaine place mémoire adaptée au type de la variable et lui associé un
											identificateur. Un identificateur (tout nom que l’on choisit) peut être formé des lettres A à Z, de chiffres 0 à
											9, de certains caractères spéciaux. Il ne doit pas comporter d’espace et ne doit pas dépasser 127 caractères. 
											L’identificateur doit être significatif. Le premier caractère composant un identificateur doit être une lettre. 
											Le langage Pascal ne fait pas de différence de casse (majuscule/minuscule)
										<li>Les types simples connus en Pascal sont : real : nombre réel ; integer : entier naturel ; char : un caractère et 
											booléen<br>
									</ul>
								</font>
							<li class="belge"><u>entrer de données</u>
									<u class="crime"><i>Syntaxe :</u></i><font color="azure"> readln NomVar ;</font>
									<font color="azure">
										<ul>
											<li>Cette instruction permet l’entrer au clavier d’une variable. Il faut veiller à ce que cette entrée corresponde
												bien au type de la variable attend une entrée. Il est judicieux d’affiché au part avant un message pour 
												indiquer ce qu’on attend</br>
										</ul>
									</font>
							<li class="belge"><u>Affichage de données</u>
								<font color="azure">
									<u class="crime"><i>Syntaxe :</u></i> writeln(Message) ;<br>
								</font>
						</ul><br>
					<li class="titre"><u><b>Structures de contrôle</b></u>
						<ol type=1>
							<li class="crime"><u><i>Structure alternative</u></i>
								<ul>
									<li class="belge"><u>Forme générale :</u>
										<font color="azure">
											<ul>
												<il>if (cond)then 
													<ul>
														<il>Inst1
													</ul> 
												<il>Else
													<ul>
														<il>Inst2 ;
													</ul>
											</ul>
										</font>
										<font size=4>
									<li class="belge"><u>Bloc d’instruction :</u>
									<font color="azure">
										<ul>
											<il>if(cond)then
												<ul>Begin<br>
													<ul>Inst1;</ul>
													<ul>Inst2;</ul>
												</ul>
												<ul>End</ul>
											<il>Else
												<ul>Begin
													<ul>Inst4;</ul>
													<ul>Inst5;</ul>
												</ul>
												<ul>End;</ul>
										</ul>
										<br><u class="crime"><b>REMARQUE</b></u>
											<ul>
												<li>L’opérateur d’affection est  “:=”
												<li>Un bloc d’instruction sera délimité par « begin et end ; »
												<li>Dans une structure alternative, dans sa forme générale, l’instruction avant « else » ne se termine pas 
													par « ; »
												<li>Après « then » , on passe du côté « oui »<br>
											</ul>
									</font>
								</ul><br>
							<li class="crime"><i><u>structure itérative</i></u>
								<ul>
									<li class="belge"><u>La boucle « while » (tant que)</u>
										<br><u class="crime">Syntaxe :</u>
										<font color="azure">
										<br>init ;
											<dl>While cond do
												<dt>Begin<br>
													<dd>Inst1 ;</br>
													<dd>Inc ;</br>
												<dt>End ;</br>
													<dd>Inst2; 
											</dl>
											
											<br>• « while » signifie « tant que ».elle permet de répéter l’exécution d’une ou plusieurs instructions. La 
												condition d’arrêt est une expression booléenne. Les instructions à l’intérieur de la boucle seront exécutées
												tant que la condition d’arrêt reste vraie.
											<br><u class="crime">NB : </u>les variables de la condition d’arrêt doivent être initialisés avant le « while ».
												le « while » continue de boucler tant que la condition d’arrêt n’est pas fausse. Pour éviter une boucle infinie
												, il faut obligatoirement que parmi les instructions de la boucle il y en ait une rendant la condition d’arrêt
												fausse à un moment donées.<br>
										</font>
									<li  class="belge"><u>la boucle « for »</u>
										<br><u class="crime">-syntaxe :</u> 
										<font color="azure">
											<br>for compteur=début to fin do
												<ul>{begin}</ul>
													<ul><ul>Inst1 ;</ul></ul>
												<ul>{end ;}</ul>
													<ul><ul>Inst2 ;</ul></ul>
											<br>• Cette expression signifie « pour ». « compteur » est la variable de boucle, » début et fin » sont 
												respectivement les bornes <et>. « début et fin » sont d’abord évalués puis « compteur » prend la valeur de 
												« début ». si compteur <= fin, alors inst1 est exécutée puis « compteur » est incrémenté de 1.</br>
											<br>NB : l’instruction de la boucle (inst1) n’est pas exécutée en si début>fin. Il est totalement interdit de 
												modifier la valeur du compteur dans le corps de la boucle. L’incrément de 1 n’est pas modifiable. Pour avoir
												une boucle « for » décroissante on écrit :
													<br>For Compteur= Fin down to Début do 
														<ul>{begin}</ul>
															<ul><ul>Inst1;</ul></ul>
														<ul>{end;}</ul>
															<ul><ul>Inst2;<br></ul></ul>
										</font>
									<li class="belge"><u>la boucle “repeat”</u>
										<br><u class="crime">Syntaxe:</u><br>
										<font color="azure">
											<dh>repeat
												<dd>Inst1;</dd>
												<dd>Inst2;</dd>
												<dd>Inst n;</dd>
											</dh>
											<dh>Until cond;</dh>
											<br>• Cette instruction signifie “repeater …jusqu’à …”. Elle permet comme le « while » de répéter l’exécution 
												d’une ou plusieurs instructions. La condition d’arrêt est une expression booléenne. Le bloc d’instruction est 
												exécuté puis la condition d’arrêt est évaluée. Si cette dernière est vraie alors on s’arrête sinon on continue.
												</br>
											<br><u class="crime">NB :</u>  Le bloc d’instruction est exécutée au moins 1 fois. Le test de la condition d’arrêt
												étant évalué après le bloc d’instruction, cette condition peut être affectée dans le bloc. Pas besoin 
												d’encadrer le bloc d’instruction par un « begin et end », le « repeat et until » joue déjà ce rôle.</br>
										</font>
								</ul><br>
							<li class="titre"><b><u> Choix de la boucle</b></u><br>
							<font color="azure">
								• Si le nombre d’itération est connu aprioris, on utilise la « boucle for »<br>
								• Sinon :
									<br>* on utilise « repeat » quand il y a toujours au moins une itération
									<br>* on utilise « while » quand le nombre d’itération peut être nul <br><p>
							</font>
						</ol>
				</ol>
			</div>
			
			<center><h1><font>LA PROGRAMMATION EN PROCEDURE SEPAREE</b></h1></center></font></p>
			<div>
				<font size=4><font color="azure">
					<ul>
					<il><u class="belge"><b>Procédure</u></b><br>
						Une procédure est un sous programme. Ecrire des procédures permet de découper un programme en plusieurs morceaux. Chaque procédure 
						définit une nouvelle instruction que l’on peu appeler en tout endroit du programme. On peut ainsi réutiliser le code d’un sous 
						programme.</br>
						
							<b><u class="demo"><i>Procédure sans paramètre</b></u></i><br>
							<ol type=a>
								<li class="special"><u>Principe</u><br>
								<font color="azure">
									Il s’agit simplement de donner un  nom à un groupe d’instruction. Ensuite, l’appel de ce nom à divers endroit du programme 
									provoque à chaque fois l’exécution de ce groupe d’instruction.</br>
									<u class="por">NB : </u>le nom de la procédure est un identificateur. On déclare toute procédure avant le « begin » du 
									programme principale.<br>
								</font>
								<li class="special"><b><u>Appel </u></b><br>
								<font color="azure">
									On peut très bien appeler une procédure P1 depuis une procédure P2, mais il faut que la procédure P1 ait été déclarée 
									avant la procédure P2.<br>
								</font>
								<li class="special"><u class="special"><b>Variable local</u></b>
								<font color="azure">
									<br>Les objets du programme qui ne sont utiles que dans la procédure peuvent être définit dans les déclarations locales de 
									la procédure.<br>
								</font>
							</ol>
					</ul>
			</div>
		</div>
    </body>
</html>